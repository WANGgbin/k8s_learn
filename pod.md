# 是什么

定义了容器的设计模式，若干有亲密性的容器可以放在一个 pod 中。pod 是 k8s 中的调度单位。

# 为什么？解决了什么问题？

实际业务中，一些进程之间是有密切的调用关系的。比如要收集业务进程的日志或者 metric 信息，就需要主业务进程与其他旁路的进程进行频繁的网络调用。
这些容器进程当然可以部署到不同的节点上，但是这样进行网络调用相比于 uds(unix domain socket) 性能比较差(uds 不过协议栈)。所以，这种场景下，
如果能够通过某种方式保证这两个容器进程总是能在一个节点上，就可以通过 uds 通信，性能更好。

除此以外，一些容器进程之间需要共享 volume 信息。比如 war 包与 web 服务器。web 容器进程依赖 war 包运行。我们当然可以把 war 包打包到 web 的
镜像中，但这样没改动一次 war 包，就需要构建一个镜像，比较麻烦。一种思路就是先启动一个 war 容器，该 war 镜像中包含 war 包，将 war 包写入到
主机 volume 中，然后 web 容器从 volume 中读取 war 包。

总而言之，某些场景下，一些容器具有超亲密关系，需要共享某些资源(超亲密关系：共享 volume、uds 通信、共享某些 namespace)。而 pod 就是为了解决这个问题。

# 怎么做？

注意：**pod 是 k8s 中的一个逻辑概念，可以有多种实现。**

pod 指的是共享某些资源的多个容器。具体来说：一个 pod 中的多个容器共享 network namespace，并且可以声明共享同一个 volume。**pod 是 k8s 中的调度单位。**

在 pod 的具体实现上，可以有多种实现方式。比如 docker cri 的实现，就是先搞一个 infra 容器，hold pod 资源，然后其他容器加入到这个资源中。一些 cri 实现，
pod 资源可以通过虚拟机实现，然后容器加入到这个虚拟机即可。总之，pod 由 CRI 实现。